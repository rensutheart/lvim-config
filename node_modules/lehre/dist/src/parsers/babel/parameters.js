"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getParameter = exports.getType = exports.getText = void 0;
var helper_1 = require("./helper");
var getText = function (lines, start, end) {
    // Slice source code between start to end.
    var line = /[A-z0-9_-]/.exec(lines[start.line]);
    var indent = (line && line.index) || 0;
    var types = lines.slice(start.line, end.line + 1);
    var length = types.length;
    return types
        .map(function (t, i) {
        if (length === 1) {
            // Signature is oneline
            return t.slice(start.column, end.column).trim();
        }
        // Slice first line
        if (i === start.line - 1) {
            return t.slice(start.column).trim();
        }
        // Slice first line
        if (i === end.line - 1) {
            return t.slice(0, end.column).trim();
        }
        return "" + ' '.repeat(indent) + t.trim();
    })
        .join('\n');
};
exports.getText = getText;
var getAlias = function (node) {
    switch (node.type) {
        case 'TSArrayType':
        case 'TSTypeReference':
        case 'TSUnionType':
            return '';
    }
    return 'Object';
};
var getType = function (node, lines) {
    switch (node.type) {
        case 'TSNumberKeyword':
            return { type: 'number', alias: 'number' };
        case 'TSStringKeyword':
            return { type: 'string', alias: 'string' };
        case 'TSBooleanKeyword':
            return { type: 'boolean', alias: 'boolean' };
        case 'TSVoidKeyword':
            return { type: 'void', alias: 'void' };
        case 'TSAnyKeyword':
            return { type: 'any', alias: 'any' };
        case 'ObjectExpression':
        case 'TSTypeLiteral':
        case 'TSArrayType':
        case 'TSTypeReference':
        case 'TSUnionType':
            if (node.loc) {
                var _a = helper_1.getLocation(node), start = _a.start, end = _a.end;
                var alias = getAlias(node);
                var type = exports.getText(lines, start, end);
                return { type: type, alias: alias };
            }
            return { type: '', alias: 'Object' };
        case 'TSFunctionType':
            if (node.loc) {
                var _b = helper_1.getLocation(node), start = _b.start, end = _b.end;
                var type = exports.getText(lines, start, end);
                return { type: type, alias: 'Function' };
            }
            return { type: 'Function', alias: 'Function' };
        case 'TSConstructorType':
            if (node.loc) {
                var _c = helper_1.getLocation(node), start = _c.start, end = _c.end;
                var type = exports.getText(lines, start, end);
                return { type: type, alias: 'Class' };
            }
            return { type: 'Function', alias: 'Function' };
        default:
            return { type: '', alias: '' };
    }
};
exports.getType = getType;
var getParameter = function (node, lines) {
    var param = {
        name: '',
        default: '',
        type: '',
        alias: '',
    };
    switch (node.type) {
        case 'TSParameterProperty':
            param.name = node.parameter.name;
            if (node.parameter.typeAnnotation) {
                var _a = exports.getType(node.parameter.typeAnnotation.typeAnnotation, lines), type = _a.type, alias = _a.alias;
                param.type = type;
                param.alias = alias;
            }
            break;
        case 'Identifier':
            param.name = node.name;
            if (node.typeAnnotation) {
                var _b = exports.getType(node.typeAnnotation.typeAnnotation, lines), type = _b.type, alias = _b.alias;
                param.type = type;
                param.alias = alias;
            }
            break;
        case 'ObjectPattern':
            // const foo = ({ arg: 'foo' }) => {}
            if (node.typeAnnotation) {
                var _c = exports.getType(node.typeAnnotation.typeAnnotation, lines), type = _c.type, alias = _c.alias;
                param.type = type;
                param.alias = alias;
            }
            break;
        case 'AssignmentPattern':
            var left = node.left;
            param.name = left.name;
            if (left.typeAnnotation) {
                var _d = exports.getType(left.typeAnnotation.typeAnnotation, lines), type = _d.type, alias = _d.alias;
                param.type = type;
                param.alias = alias;
            }
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var value = node.right.extra.raw;
            param.default = value || exports.getType(node.right, lines).type;
            break;
    }
    return param;
};
exports.getParameter = getParameter;
