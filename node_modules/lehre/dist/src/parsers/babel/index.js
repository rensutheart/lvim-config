"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = void 0;
var classes_1 = require("./classes");
var functions_1 = require("./functions");
var helper_1 = require("./helper");
var interfaces_1 = require("./interfaces");
var variables_1 = require("./variables");
var helpers_1 = require("../helpers");
var parse = function (_a) {
    var code = _a.code, lines = _a.lines, scriptKind = _a.scriptKind;
    var ast = helper_1.getAst(code, scriptKind);
    var docs = [];
    var visit = function (node) {
        if (node.leadingComments && helper_1.isCommentBlock(node.leadingComments)) {
            return;
        }
        var start = node.loc
            ? { line: node.loc.start.line - 1, column: node.loc.start.column }
            : { line: 0, column: 0 };
        var end = node.loc
            ? { line: node.loc.end.line - 1, column: node.loc.end.column }
            : { line: 0, column: 0 };
        switch (node.type) {
            case 'VariableDeclaration':
                var declaration = node.declarations[0];
                var init = declaration.init;
                if (init && init.type === 'ArrowFunctionExpression') {
                    docs.push(__assign(__assign({}, variables_1.getVariableDoc(node.declarations[0], lines)), { start: start, end: end }));
                }
                break;
            case 'TSInterfaceDeclaration':
                docs.push(__assign(__assign({}, interfaces_1.getInterfaceDoc(node, lines)), { start: start, end: end }));
                break;
            case 'ExportDefaultDeclaration':
                switch (node.declaration.type) {
                    case 'ClassDeclaration':
                        // Decorator exists
                        if (helpers_1.has(node.declaration, 'decorators')) {
                            var _a = helper_1.getLocation(node.declaration), start_1 = _a.start, end_1 = _a.end;
                            docs.push(__assign(__assign({}, classes_1.getClassDoc(node.declaration, lines)), { start: start_1, end: end_1 }));
                        }
                        else {
                            docs.push(__assign(__assign({}, classes_1.getClassDoc(node.declaration, lines)), { start: start, end: end }));
                        }
                        break;
                    case 'FunctionDeclaration':
                        docs.push(__assign(__assign({}, functions_1.getFunctionDoc(node.declaration, lines)), { start: start, end: end }));
                        break;
                    default:
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        var type = node.declaration.type;
                        if (type === 'TSInterfaceDeclaration') {
                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                            var declaration_1 = node.declaration;
                            docs.push(__assign(__assign({}, interfaces_1.getInterfaceDoc(declaration_1, lines)), { start: start, end: end }));
                        }
                }
                break;
            case 'ClassDeclaration':
                docs.push(__assign(__assign({}, classes_1.getClassDoc(node, lines)), { start: start, end: end }));
                break;
            case 'ExportNamedDeclaration':
                if (!node.declaration) {
                    break;
                }
                switch (node.declaration.type) {
                    case 'ClassDeclaration':
                        // `export class Foo {}`
                        if (helpers_1.has(node.declaration, 'decorators')) {
                            // Decorator exists
                            var _b = helper_1.getLocation(node.declaration), start_2 = _b.start, end_2 = _b.end;
                            docs.push(__assign(__assign({}, classes_1.getClassDoc(node.declaration, lines)), { start: start_2, end: end_2 }));
                        }
                        else {
                            docs.push(__assign(__assign({}, classes_1.getClassDoc(node.declaration, lines)), { start: start, end: end }));
                        }
                        break;
                    case 'VariableDeclaration':
                        // `export const foo = () => {}`
                        var declaration_2 = node.declaration;
                        var init_1 = declaration_2.declarations[0].init;
                        if (init_1 && init_1.type === 'ArrowFunctionExpression') {
                            docs.push(__assign(__assign({}, variables_1.getVariableDoc(declaration_2.declarations[0], lines)), { start: start, end: end }));
                        }
                        break;
                    case 'FunctionDeclaration':
                        // `export function foo() {}`
                        docs.push(__assign(__assign({}, functions_1.getFunctionDoc(node.declaration, lines)), { start: start, end: end }));
                        break;
                    case 'TSInterfaceDeclaration':
                        // `export interface Foo {}`
                        docs.push(__assign(__assign({}, interfaces_1.getInterfaceDoc(node.declaration, lines)), { start: start, end: end }));
                        break;
                }
                break;
            case 'FunctionDeclaration':
                docs.push(__assign(__assign({}, functions_1.getFunctionDoc(node, lines)), { start: start, end: end }));
                break;
        }
    };
    ast.program.body.forEach(function (stmt) {
        visit(stmt);
    });
    return docs;
};
exports.parse = parse;
